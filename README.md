# RocketMQ重试机制的实现原理

## 1. 重试队列机制

当消费者处理消息失败并抛出异常时，`RocketMQ`会：

1. 第一步：将消息发送到重试队列

   - 重试队列名称：`%RETRY%{ConsumerGroup}`


   - 例如：`%RETRY%order-timeout-consumer-group`

2. 第二步：根据重试次数设置延时

   ```
      重试次数    延时间隔
      1          10秒
      2          30秒  
      3          1分钟
      4          2分钟
      5          3分钟
      6          4分钟
      ...
      16         2小时（最大间隔）
   ```

3. 第三步：到达延时时间后，重新投递消息

## 2. 重试过程详解

假设有一条消息处理失败：

1. 第1次失败：消息进入 `%RETRY%order-timeout-consumer-group`，10秒后重新投递

2. 第2次失败：再次进入重试队列，30秒后重新投递

3. 第3次失败：再次进入重试队列，1分钟后重新投递

4. 第4次失败（超过`maxReconsumeTimes=3`）：消息进入死信队列 `%DLQ%order-timeout-consumer-group`，不再自动重试



实现了一个基于Redis的分布式锁来保护缓存重建的过程

1. 双重检查：

- 第一次检查缓存

- 获取锁后再次检查缓存

- 避免重复重建缓存

1. 分布式锁实现：

- 使用SETNX命令

- 设置过期时间防止死锁

- 使用Lua脚本保证原子性

1. 异常处理：

- 获取锁失败时等待重试

- 发生异常时降级到直接查询数据库

- 确保锁一定会被释放

1. 性能优化：

- 锁的粒度精确到活动级别

- 使用UUID作为请求标识

- 合理的锁超时时间





mq消息幂等性

这样，我们就实现了一个完整的消息幂等性处理机制。主要特点：

1. 消息ID机制：

- 每条消息都有唯一的ID

- 使用UUID生成消息ID

- 消息ID用于幂等性检查

1. 幂等性检查：

- 使用Redis的SETNX命令

- 设置合理的过期时间

- 异常时安全处理

1. 处理流程：

- 先检查消息是否处理过

- 处理成功后标记消息

- 异常时删除标记允许重试

1. 异常处理：

- 幂等性检查异常时认为已处理

- 业务处理异常时允许重试

- 完善的日志记录

1. 性能优化：

- 使用Redis实现高效检查

- 合理的过期时间设置

- 异常时快速失败

1. 可靠性保证：

- 消息处理前检查

- 处理成功后标记

- 异常时允许重试

1. 可维护性：

- 清晰的代码结构

- 详细的日志记录

- 统一的异常处理



消息可靠性

1. 消息生产者优化：

- 同步发送等待结果

- 消息ID和时间戳

- 发送结果检查

- 本地消息表记录

1. 本地消息表机制：

- 消息持久化存储

- 消息状态追踪

- 定时重试机制

- 异常处理机制

1. 消息状态管理：

- PENDING：待发送

- SENT：已发送

- FAILED：发送失败

- RETRYING：重试中

- RETRY_FAILED：重试失败

1. 重试机制：

- 定时任务扫描

- 失败消息重试

- 状态更新

- 异常处理

1. 数据库设计：

- 消息ID唯一索引

- 状态和时间索引

- 完整的字段注释

- 合理的字段类型

1. 异常处理：

- 详细的日志记录

- 异常状态更新

- 重试机制

- 告警通知

1. 性能优化：

- 批量处理

- 索引优化

- 定时任务间隔

- 异常降级

