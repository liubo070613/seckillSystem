# RocketMQ重试机制的实现原理

## 1. 重试队列机制

当消费者处理消息失败并抛出异常时，`RocketMQ`会：

1. 第一步：将消息发送到重试队列

   - 重试队列名称：`%RETRY%{ConsumerGroup}`


   - 例如：`%RETRY%order-timeout-consumer-group`

2. 第二步：根据重试次数设置延时

   ```
      重试次数    延时间隔
      1          10秒
      2          30秒  
      3          1分钟
      4          2分钟
      5          3分钟
      6          4分钟
      ...
      16         2小时（最大间隔）
   ```

3. 第三步：到达延时时间后，重新投递消息

## 2. 重试过程详解

假设有一条消息处理失败：

1. 第1次失败：消息进入 `%RETRY%order-timeout-consumer-group`，10秒后重新投递

2. 第2次失败：再次进入重试队列，30秒后重新投递

3. 第3次失败：再次进入重试队列，1分钟后重新投递

4. 第4次失败（超过`maxReconsumeTimes=3`）：消息进入死信队列 `%DLQ%order-timeout-consumer-group`，不再自动重试



实现了一个基于Redis的分布式锁来保护缓存重建的过程

1. 双重检查：

- 第一次检查缓存

- 获取锁后再次检查缓存

- 避免重复重建缓存

1. 分布式锁实现：

- 使用SETNX命令

- 设置过期时间防止死锁

- 使用Lua脚本保证原子性

1. 异常处理：

- 获取锁失败时等待重试

- 发生异常时降级到直接查询数据库

- 确保锁一定会被释放

1. 性能优化：

- 锁的粒度精确到活动级别

- 使用UUID作为请求标识

- 合理的锁超时时间



